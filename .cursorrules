# NestJS Codebase Rules & Best Practices

## Core Principles
1. **Follow NestJS Architecture**: Module → Controller → Service → Repository pattern
2. **Single Responsibility**: Each class/function should have one clear purpose
3. **DRY (Don't Repeat Yourself)**: Extract common logic to shared utilities
4. **Type Safety**: Always use TypeScript types, avoid `any` unless absolutely necessary
5. **HIPAA Compliance**: All code must consider security, audit logging, and data protection

## File & Directory Structure

### Module Structure
- Each feature module must follow: `module-name.module.ts`, `module-name.controller.ts`, `module-name.service.ts`
- Entities go in `entities/` subfolder
- DTOs go in `dto/` subfolder
- Interfaces go in `interfaces/` subfolder
- Serializers go in `serializers/` subfolder
- Constants go in `constants/` subfolder

### Naming Conventions
- **Files**: kebab-case (e.g., `user-profile.service.ts`)
- **Classes**: PascalCase (e.g., `UserProfileService`)
- **Variables/Functions**: camelCase (e.g., `getUserProfile`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_RETRY_COUNT`)
- **Interfaces**: PascalCase with `Interface` suffix (e.g., `UserInterface`)
- **DTOs**: PascalCase with `Dto` suffix (e.g., `CreateUserDto`)
- **Entities**: PascalCase (e.g., `User`)
- **Enums**: PascalCase (e.g., `UserRole`)

## Code Organization

### Controllers
- Controllers should ONLY handle HTTP requests/responses
- NO business logic in controllers
- Use DTOs for request validation
- Return serialized responses using serializers
- Maximum 10-15 lines per controller method
- Use appropriate HTTP decorators: `@Get()`, `@Post()`, `@Put()`, `@Delete()`, `@Patch()`
- Always use guards for protected routes: `@UseGuards(JwtAuthGuard)`

### Services
- Services contain ALL business logic
- Services can inject repositories and other services
- Methods should be focused and single-purpose
- Use dependency injection properly
- Handle errors appropriately (throw exceptions, don't return null/undefined for errors)
- Maximum 50 lines per method (extract to smaller methods if needed)

### Repositories
- Repositories handle ONLY database operations
- Extend TypeORM Repository when custom queries needed
- Use QueryBuilder for complex queries
- Always use transactions for multi-step operations
- Return entities, not DTOs

### DTOs (Data Transfer Objects)
- Create separate DTOs for Create, Update, and Query operations
- Use class-validator decorators for validation
- Use class-transformer for transformation
- Example: `CreateUserDto`, `UpdateUserDto`, `QueryUserDto`

### Entities
- Use TypeORM decorators properly
- Include audit fields: `createdAt`, `updatedAt`, `createdBy`, `updatedBy` for HIPAA compliance
- Use indexes for frequently queried fields
- Never expose sensitive fields (passwords) in serialization

## TypeScript Best Practices

### Types & Interfaces
- Prefer interfaces over types for object shapes
- Use `interface` for contracts, `type` for unions/intersections
- Always define return types explicitly
- Use generic types when appropriate
- Avoid `any` - use `unknown` if type is truly unknown

### Imports
- Group imports: external packages → internal modules → relative imports
- Use absolute imports from `src/` root when possible
- Remove unused imports
- Order: NestJS → Third-party → Internal

### Error Handling
- Use NestJS built-in exceptions: `BadRequestException`, `NotFoundException`, `UnauthorizedException`, etc.
- Create custom exceptions in `common/exceptions/` if needed
- Always log errors for audit trail (HIPAA requirement)
- Never expose internal error details to clients in production

## Comments & Documentation

### When to Comment
- Complex business logic that isn't self-explanatory
- HIPAA compliance requirements
- Workarounds for third-party library issues (with ticket reference)
- Public API methods (use JSDoc)

### When NOT to Comment
- Self-explanatory code
- Obvious variable names
- Simple getters/setters
- Standard CRUD operations

### Comment Style
- Use JSDoc for public methods: `/** Description */`
- Use `//` for inline explanations
- Comments should explain WHY, not WHAT
- Keep comments up-to-date with code changes

## NestJS Specific Rules

### Dependency Injection
- Always use constructor injection
- Mark services with `@Injectable()`
- Use `@InjectRepository()` for TypeORM repositories
- Use `@Inject()` for custom providers

### Modules
- Each feature should have its own module
- Import only what's needed
- Export services that other modules need
- Use `forRoot()` for configuration modules
- Use `forFeature()` for feature modules

### Guards
- Create guards in `common/guards/`
- Use `@UseGuards()` decorator
- Guards should be reusable and focused

### Interceptors
- Use interceptors for cross-cutting concerns (logging, transformation)
- Create in `common/interceptors/`
- Apply globally or per-route as needed

### Pipes
- Use pipes for validation and transformation
- Use built-in ValidationPipe with DTOs
- Create custom pipes in `common/pipes/`

### Filters
- Use exception filters for error handling
- Create in `common/exceptions/` or `common/filters/`
- Log all exceptions for HIPAA audit trail

## Security & HIPAA Compliance

### Authentication & Authorization
- Always validate JWT tokens
- Use role-based access control (RBAC)
- Never trust client input - validate everything
- Use parameterized queries (TypeORM handles this)

### Data Protection
- Mask sensitive data in logs (emails, phone numbers)
- Encrypt sensitive data at rest
- Use HTTPS in production
- Implement proper session management

### Audit Logging
- Log all authentication attempts
- Log all data access (read/write)
- Log all exceptions and errors
- Store audit logs securely (7-year retention for HIPAA)

## Code Quality

### Functions & Methods
- Maximum 50 lines per function
- Maximum 3 parameters (use objects for more)
- Functions should do one thing well
- Extract complex logic to separate functions

### Variables
- Use descriptive names (avoid abbreviations)
- Declare variables close to usage
- Use `const` by default, `let` when reassignment needed
- Never use `var`

### Classes
- Maximum 300 lines per class
- Single responsibility principle
- Use composition over inheritance
- Keep methods focused and cohesive

### Testing
- Write unit tests for services
- Write integration tests for controllers
- Test edge cases and error scenarios
- Aim for 80%+ code coverage

## Performance

### Database
- Use indexes for frequently queried fields
- Avoid N+1 queries (use relations properly)
- Use pagination for list endpoints
- Cache frequently accessed data

### API
- Use compression middleware
- Implement rate limiting
- Use caching where appropriate
- Optimize response payloads

## Git & Version Control

### Commit Messages
- Use conventional commits: `feat:`, `fix:`, `refactor:`, `docs:`, `test:`
- Be descriptive but concise
- Reference ticket numbers if applicable

### Code Review
- All code must be reviewed before merge
- Check for security vulnerabilities
- Verify HIPAA compliance
- Ensure tests pass

## Common Patterns

### Response Format
```typescript
// Success Response
{
  success: true,
  statusCode: 200,
  data: {...},
  message: "Operation successful"
}

// Error Response
{
  success: false,
  statusCode: 400,
  message: "Error message",
  errors: {...}
}
```

### Service Method Pattern
```typescript
async methodName(params: ParamDto): Promise<ReturnType> {
  // 1. Validate input
  // 2. Business logic
  // 3. Database operations
  // 4. Return result
}
```

### Controller Method Pattern
```typescript
@Get(':id')
@UseGuards(JwtAuthGuard)
async findOne(@Param('id') id: string): Promise<SuccessSerializer> {
  const result = await this.service.findOne(id);
  return SuccessHelper.createSuccessResponse(result);
}
```

## Anti-Patterns to Avoid

1. ❌ Business logic in controllers
2. ❌ Direct database access in controllers
3. ❌ Using `any` type
4. ❌ Nested callbacks (use async/await)
5. ❌ Ignoring errors (always handle)
6. ❌ Hardcoded values (use constants/config)
7. ❌ Duplicate code (extract to utilities)
8. ❌ Large files (split into modules)
9. ❌ Circular dependencies
10. ❌ Exposing sensitive data in responses

## File Size Limits
- Controller: Max 200 lines
- Service: Max 500 lines
- Module: Max 100 lines
- Entity: Max 150 lines
- DTO: Max 100 lines

## Linting & Formatting
- Use ESLint with NestJS rules
- Use Prettier for formatting
- Run linter before committing
- Fix all warnings and errors

## Documentation Requirements
- README.md for each major module
- API documentation using Swagger/OpenAPI
- JSDoc for public APIs
- Architecture decision records (ADRs) for major decisions

## Database Schema & Design

### Schema Design Principles
- **Normalization**: Follow 3NF (Third Normal Form) - eliminate redundant data, ensure data integrity
- **Denormalization**: Only when performance requires it (document the reason)
- **Naming Conventions**:
  - Tables: plural, snake_case (e.g., `users`, `user_profiles`, `medical_records`)
  - Columns: snake_case (e.g., `first_name`, `created_at`, `is_active`)
  - Indexes: `idx_<table>_<columns>` (e.g., `idx_users_email`, `idx_medical_records_patient_id`)
  - Foreign Keys: `fk_<table>_<referenced_table>` (e.g., `fk_appointments_patient_id`)
  - Unique Constraints: `uq_<table>_<columns>` (e.g., `uq_users_email`)
- **Primary Keys**: Always use UUID (`uuid` type) for HIPAA compliance (non-sequential, harder to enumerate)
- **Foreign Keys**: Always define with `ON DELETE` and `ON UPDATE` actions explicitly
- **Timestamps**: Use `timestamp` with timezone (`timestamptz` in PostgreSQL) for all date fields

### Entity Design Rules
- **Required Fields**: Every entity MUST include:
  - `id`: UUID primary key
  - `createdAt`: timestamp (audit trail)
  - `updatedAt`: timestamp (audit trail)
  - `createdBy`: string (user ID who created - HIPAA requirement)
  - `updatedBy`: string (user ID who updated - HIPAA requirement)
- **Soft Deletes**: Use `deletedAt` timestamp for soft deletes (never hard delete PHI data)
- **Column Types**: 
  - Use appropriate types: `varchar(n)` with explicit length limits
  - Use `text` only when length is truly variable/unbounded
  - Use `boolean` for flags, not `tinyint` or `char(1)`
  - Use `numeric` or `decimal` for financial/medical calculations (never `float` or `double`)
- **Nullable Fields**: Explicitly mark nullable fields - avoid nullable unless business requires it
- **Default Values**: Set appropriate defaults for boolean flags and status fields
- **Enums**: Use PostgreSQL ENUM types or TypeORM enum for fixed value sets

### Indexing Strategy
- **Primary Indexes**: Automatic on primary key (UUID)
- **Foreign Key Indexes**: Always create indexes on foreign key columns
- **Query Optimization**: Index columns used in:
  - WHERE clauses (frequently filtered)
  - JOIN conditions
  - ORDER BY clauses (for large datasets)
  - GROUP BY clauses
- **Composite Indexes**: Create for multi-column queries (order matters - most selective first)
- **Unique Indexes**: Use for business-unique constraints (email, SSN, etc.)
- **Partial Indexes**: Use for filtered queries (e.g., `WHERE isActive = true`)
- **Index Naming**: Follow pattern `idx_<table>_<column1>_<column2>`
- **Avoid Over-Indexing**: Don't index every column - balance query performance vs. write performance

### Relationships & Foreign Keys
- **Explicit Relationships**: Always define relationships in TypeORM entities
- **Cascade Rules**: 
  - Use `CASCADE` only when business logic requires it
  - Default: `RESTRICT` or `SET NULL` for safety
  - Never cascade delete for PHI-related tables
- **Join Tables**: Use explicit join tables for many-to-many relationships
- **Lazy Loading**: Use `@ManyToOne(() => Entity, { lazy: true })` for optional relationships
- **Eager Loading**: Only when always needed (avoid N+1 queries)

### Scalability Considerations
- **Partitioning**: Consider table partitioning for:
  - Large tables (>10M rows)
  - Time-series data (partition by date)
  - High-write tables (partition by hash)
- **Archiving Strategy**: Plan for data archival:
  - Move old data to archive tables
  - Keep audit trail accessible for 7 years (HIPAA requirement)
- **Read Replicas**: Design queries to work with read replicas for scaling reads
- **Connection Pooling**: Configure appropriate pool size (default: 10-20 connections)
- **Query Optimization**:
  - Use `EXPLAIN ANALYZE` for slow queries
  - Avoid `SELECT *` - select only needed columns
  - Use pagination for all list endpoints (default: 20-50 items per page)
  - Implement cursor-based pagination for large datasets
- **Materialized Views**: Use for complex aggregations that don't need real-time data

### Migration Best Practices
- **Migration Naming**: `YYYYMMDDHHMMSS-<descriptive-name>.ts` (e.g., `20240115143000-add-user-email-index.ts`)
- **Reversible Migrations**: Always write both `up()` and `down()` methods
- **Data Migrations**: Separate schema changes from data migrations
- **Zero-Downtime**: Design migrations for zero-downtime deployments:
  - Add columns as nullable first, then populate, then make required
  - Add indexes concurrently: `CREATE INDEX CONCURRENTLY`
  - Drop columns in multiple steps (mark unused, then drop)
- **Testing**: Test migrations on staging before production
- **Rollback Plan**: Always have a rollback strategy
- **Large Migrations**: Break into smaller, incremental migrations

### Query Optimization Rules
- **Avoid N+1 Queries**: Use `relations` or `QueryBuilder` with joins
- **Use QueryBuilder**: For complex queries instead of multiple repository calls
- **Transactions**: Wrap multi-step operations in transactions
- **Batch Operations**: Use `save()` with arrays for bulk inserts/updates
- **Select Specific Fields**: Never use `SELECT *` in production queries
- **Limit Results**: Always use `take()` or `limit()` for list queries
- **Use EXISTS**: Instead of `COUNT(*) > 0` for existence checks
- **Avoid Functions in WHERE**: Don't use functions on indexed columns in WHERE clauses

### Data Integrity
- **Constraints**: Use database constraints (NOT NULL, CHECK, UNIQUE, FOREIGN KEY)
- **Validation**: Validate at both DTO level (application) and database level (constraints)
- **Transactions**: Use transactions for:
  - Multi-table operations
  - Financial transactions
  - Any operation that must be atomic
- **Locking**: Use appropriate locking strategies (optimistic vs pessimistic)
- **Unique Constraints**: Enforce at database level, not just application level

## HIPAA Compliance - Database Security

### Encryption at Rest
- **Database-Level Encryption**: 
  - Use PostgreSQL Transparent Data Encryption (TDE) or cloud provider encryption
  - Enable encryption for database files, backups, and snapshots
  - Use encrypted storage volumes (AWS EBS encryption, Azure Disk Encryption, etc.)
- **Application-Level Encryption**:
  - Encrypt PHI (Protected Health Information) fields before storing
  - Use AES-256 encryption for sensitive fields (SSN, medical records, etc.)
  - Store encryption keys in secure key management service (AWS KMS, Azure Key Vault, HashiCorp Vault)
  - Never store encryption keys in code or environment variables
- **Field-Level Encryption**: Encrypt these fields at application level:
  - Social Security Numbers (SSN)
  - Medical record numbers
  - Insurance information
  - Financial information
  - Any field containing PHI
- **Encryption Keys**:
  - Rotate encryption keys regularly (annually minimum)
  - Use separate keys for different environments
  - Implement key versioning for seamless rotation
  - Log all key access and usage

### Encryption in Transit
- **Database Connections**:
  - ALWAYS use SSL/TLS for database connections in production
  - Configure `ssl: { rejectUnauthorized: true }` in TypeORM config
  - Use certificate-based authentication when possible
  - Verify SSL certificate chain
- **Connection String**: Use connection strings with SSL parameters:t
  ssl: {
    rejectUnauthorized: true,
    ca: process.env.DB_SSL_CA, // Certificate Authority
    cert: process.env.DB_SSL_CERT, // Client certificate
    key: process.env.DB_SSL_KEY, // Client key
  }
  - **API Communication**: 
  - Use HTTPS only (TLS 1.2+)
  - Enforce HTTPS redirects
  - Use HSTS headers
- **Internal Network**: Even internal network communication should use encryption

### Access Control & Authentication
- **Database Users**: 
  - Use least-privilege principle for database users
  - Create separate users for application, migrations, and admin
  - Never use superuser accounts for application connections
  - Rotate database passwords regularly (90 days)
- **Row-Level Security**: Implement PostgreSQL Row-Level Security (RLS) policies for multi-tenant data
- **Connection Pooling**: Limit connection pool size to prevent resource exhaustion
- **IP Whitelisting**: Restrict database access to specific IP addresses/networks
- **VPN/Private Network**: Access database only through VPN or private network (never public internet)

### Audit Logging & Monitoring
- **Database Audit Logs**: 
  - Enable PostgreSQL audit logging (pgAudit extension)
  - Log all DDL operations (CREATE, ALTER, DROP)
  - Log all DML operations on PHI tables (SELECT, INSERT, UPDATE, DELETE)
  - Log all authentication attempts (success and failure)
  - Log all administrative actions
- **Application Audit Logs**:
  - Log all data access (who, what, when, why)
  - Log all data modifications with before/after values
  - Include user ID, IP address, timestamp, and action type
  - Store audit logs in separate, immutable database/table
- **Log Retention**: 
  - Retain audit logs for minimum 7 years (HIPAA requirement)
  - Implement log archival strategy
  - Ensure logs are tamper-proof (append-only, encrypted)
- **Monitoring**:
  - Monitor for suspicious access patterns
  - Alert on failed authentication attempts
  - Alert on unusual query patterns
  - Monitor database performance and availability

### Data Backup & Recovery
- **Backup Strategy**:
  - Daily full backups
  - Continuous transaction log backups (point-in-time recovery)
  - Encrypt all backups
  - Test backup restoration regularly (monthly)
- **Backup Storage**:
  - Store backups in geographically separate location
  - Use versioned, immutable backup storage
  - Encrypt backups with separate encryption keys
- **Recovery Time Objective (RTO)**: Define and test RTO (target: <4 hours)
- **Recovery Point Objective (RPO)**: Define and test RPO (target: <1 hour data loss)

### Data Retention & Disposal
- **Retention Policy**: 
  - Define data retention policies per data type
  - Minimum 7 years for PHI (HIPAA requirement)
  - Implement automated archival for old data
- **Secure Deletion**: 
  - Use soft deletes (never hard delete PHI)
  - Implement secure data disposal procedures
  - Document data disposal in audit logs
- **Data Minimization**: Only collect and store data necessary for business purposes

### PHI Identification & Handling
- **PHI Fields**: Identify and mark all PHI fields in entities:
  - Names, addresses, dates of birth
  - Social Security Numbers
  - Medical record numbers
  - Health insurance information
  - Any information that can identify a patient
- **Field-Level Encryption**: Encrypt all PHI fields at application level
- **Access Logging**: Log all access to PHI fields
- **Data Masking**: Mask PHI in logs, error messages, and non-production environments
- **Minimum Necessary**: Only access PHI necessary for the task

### Compliance Documentation
- **Data Flow Diagrams**: Document how PHI flows through the system
- **Encryption Documentation**: Document encryption methods and key management
- **Access Control Documentation**: Document who has access to what data
- **Incident Response Plan**: Document procedures for security incidents
- **Business Associate Agreements (BAA)**: Ensure all third-party services have BAAs

### Environment-Specific Rules
- **Development**: 
  - Use anonymized/synthetic data only
  - Never use real PHI in development
  - Use separate encryption keys
- **Staging**: 
  - Use anonymized data or limited test data
  - Mirror production security controls
- **Production**: 
  - Full encryption at rest and in transit
  - Complete audit logging
  - Strict access controls
  - Regular security audits